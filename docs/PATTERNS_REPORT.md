# Отчет о примененных паттернах проектирования
## Проект "Finance Manager"

В ходе реализации проекта "Finance Manager" были использованы различные архитектурные и классические паттерны проектирования. Их применение, во многом благодаря возможностям фреймворка Spring Boot, позволило создать модульную, поддерживаемую и расширяемую архитектуру приложения.

---

### 1. Архитектурные паттерны

#### Многоуровневая архитектура (Layered Architecture)

*   **Описание:** Это фундаментальный архитектурный паттерн, который разделяет приложение на горизонтальные слои, каждый со своей зоной ответственности. Это снижает связанность компонентов и упрощает разработку.

*   **Применение в проекте:** Приложение имеет классическую трехуровневую структуру:
    *   **Слой Представления (Presentation Layer):** Реализован в пакете `com.example.fmanager.controller`. Классы с аннотацией `@RestController` (например, `AccountController`, `TransactionController`) отвечают за прием HTTP-запросов, их валидацию и возврат ответов клиенту.
    *   **Слой Бизнес-логики (Business/Service Layer):** Реализован в пакете `com.example.fmanager.service`. Классы с аннотацией `@Service` (например, `AccountService`, `TransactionService`) инкапсулируют основную бизнес-логику приложения.
    *   **Слой Доступа к данным (Data Access Layer):** Реализован с помощью интерфейсов Spring Data JPA в пакете `com.example.fmanager.repository`. Эти интерфейсы (например, `AccountRepository`, `ClientRepository`) абстрагируют взаимодействие с базой данных PostgreSQL.

---

### 2. Паттерны GoF (Gang of Four) и другие

#### Внедрение зависимостей (Dependency Injection, DI)

*   **Описание:** Паттерн, при котором зависимости объекта (другие объекты, с которыми он работает) не создаются им самим, а предоставляются извне. Это основной принцип Inversion of Control (IoC).
*   **Применение в проекте:** Spring Framework активно использует DI. В проекте это реализовано через **внедрение в конструктор**. Это делает код более модульным и упрощает тестирование.
    ```java
    // Пример из ClientController.java
    @RestController
    public class ClientController {
        private final ClientService clientService;

        // Зависимость ClientService внедряется через конструктор
        public ClientController(ClientService clientService) {
            this.clientService = clientService;
        }
    }
    ```

#### Репозиторий (Repository)

*   **Описание:** Изолирует слой бизнес-логики от деталей реализации хранилища данных. Предоставляет интерфейс для работы с сущностями как с коллекцией объектов.
*   **Применение в проекте:** Spring Data JPA позволяет реализовать этот паттерн путем создания интерфейсов, расширяющих `JpaRepository`. Фреймворк автоматически генерирует реализацию для стандартных CRUD-операций.
    ```java
    // Пример использования в AccountService.java
    public Optional<AccountGetDto> getAccountById(int id) {
        Account account = accountRepository.findById(id) // Метод из JpaRepository
                .orElseThrow(() -> new NotFoundException(ACCOUNT_NOT_FOUND_MESSAGE));
        return Optional.of(AccountGetDto.convertToDto(account));
    }
    ```

#### DTO (Data Transfer Object)

*   **Описание:** Объект, предназначенный для передачи данных между различными слоями или системами (например, между backend и frontend). Позволяет скрыть внутреннюю структуру моделей базы данных и передавать только необходимую информацию.
*   **Применение в проекте:** Активно используются DTO для различных операций:
    *   `...CreateDto` (например, `AccountCreateDto`): для получения данных при создании сущности.
    *   `...GetDto` (например, `AccountGetDto`): для отправки данных клиенту в безопасном и удобном формате.
    *   `...UpdateDto` (например, `AccountUpdateDto`): для получения данных при обновлении сущности.

#### Одиночка (Singleton)

*   **Описание:** Гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к нему.
*   **Применение в проекте:** По умолчанию все бины (beans) в Spring, аннотированные как `@Service`, `@Component`, `@RestController`, являются Одиночками. Это критически важно для таких классов, как `InMemoryCache` и `VisitCounterService`, которые должны хранить единое состояние для всего приложения.

#### Фасад (Facade)

*   **Описание:** Предоставляет простой, унифицированный интерфейс к сложной подсистеме. Скрывает внутреннюю сложность от клиента.
*   **Применение в проекте:** Классы в сервисном слое выступают в роли Фасадов. Например, метод `TransactionService.createTransaction()` является отличным примером. Он скрывает за собой целый ряд операций:
    1.  Поиск сущностей `Account` и `Category` в базе данных.
    2.  Проверку баланса счета.
    3.  Обновление баланса счета.
    4.  Поиск связанных бюджетов и проверку лимитов.
    5.  Обновление доступной суммы в бюджете.
    6.  Сохранение новой транзакции.
    7.  Очистку кэша.
    Клиент (контроллер) просто вызывает один метод, не зная о всей этой внутренней логике.

#### Прокси (Proxy) / Аспектно-ориентированное программирование (АОП)

*   **Описание:** Spring Framework активно использует прокси-объекты для декларативного добавления сквозной функциональности (cross-cutting concerns).
*   **Применение в проекте:** Аннотация `@Transactional` является ярчайшим примером. Когда метод сервиса помечается этой аннотацией, Spring создает прокси-объект, который "оборачивает" вызов метода в транзакцию базы данных. Разработчику не нужно вручную управлять началом, фиксацией (commit) или откатом (rollback) транзакции.

#### Перехватчик (Interceptor)

*   **Описание:** Позволяет перехватывать запросы до того, как они достигнут контроллера, и выполнять определенную логику.
*   **Применение в проекте:** `VisitCounterInterceptor` реализует этот паттерн. Он регистрируется в конфигурации Spring MVC и перехватывает все входящие HTTP-запросы для инкремента счетчика посещений URL с помощью `VisitCounterService`.

#### Асинхронный метод (Asynchronous Method)

*   **Описание:** Позволяет выполнять длительные операции в отдельном потоке, не блокируя основной поток, который обработал запрос.
*   **Применение в проекте:** `LogService.generateLogFileForDateAsync()` аннотирован как `@Async` и возвращает `CompletableFuture<String>`. Это позволяет немедленно вернуть ответ клиенту (`HTTP 202 Accepted`), в то время как задача по генерации лог-файла продолжает выполняться в фоновом режиме.

#### Кэш (Cache-Aside Strategy)

*   **Описание:** Простая и популярная стратегия кэширования. Логика приложения перед обращением к источнику данных (БД) сначала проверяет наличие данных в кэше. Если данных нет (cache miss), оно извлекает их из источника, сохраняет в кэш и возвращает.
*   **Применение в проекте:** `InMemoryCache` используется в нескольких сервисах (`AccountService`, `CategoryService`, `GoalService`) именно по этой стратегии.
    ```java
    // Пример из AccountService.java
    public List<AccountGetDto> findByClientId(int clientId) {
        String cacheKey = "accounts_client_" + clientId;
        if (cache.containsKey(cacheKey)) { // 1. Проверка кэша
            return (List<AccountGetDto>) cache.get(cacheKey);
        }
        // 2. Если в кэше нет -> идем в БД
        List<Account> accounts = accountRepository.findAllByClientId(clientId);
        // ...
        cache.put(cacheKey, accountGetDtos); // 3. Сохраняем в кэш
        return accountGetDtos;
    }
    ```